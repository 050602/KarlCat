{"version":3,"file":"encode_decode.js","sourceRoot":"","sources":["../../src/proto/encode_decode.ts"],"names":[],"mappings":";;;AAAA,oCAAmC;AAGnC,kCAAkC;AAElC,YAAY;AACZ,SAAgB,mBAAmB;IAC/B,OAAO,EAAE,WAAW,EAAE,SAAS,EAAE,WAAW,EAAE,SAAS,EAAE,CAAC;AAC9D,CAAC;AAFD,kDAEC;AAED,SAAS,SAAS,CAAC,OAAe,EAAE,MAAc,EAAE,MAAc,EAAE,GAAY;IAC5E,iDAAiD;IACjD,kEAAkE;IAClE,cAAc;IACd,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;IAC7B,IAAI,MAAM,GAAG,IAAI,GAAG,OAAO,CAAC,QAAQ,EAAE,GAAG,GAAG,GAAG,MAAM,GAAG,MAAM,CAAC;IAC/D,IAAA,eAAO,EAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,CAAC;IACnD,IAAI,QAAQ,GAAQ,MAAM,CAAC,MAAM,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC;IAClD,OAAO,QAAQ,CAAC;AACpB,CAAC;AAED,SAAS,SAAS,CAAC,OAAe,EAAE,MAAc,EAAE,IAAS,EAAE,GAAY;IACvE,IAAI,MAAM,GAAG,MAAM,CAAC,OAAO,CAAC,CAAC;IAC7B,IAAI,UAAU,GAAe,MAAM,CAAC,IAAI,GAAG,OAAO,GAAG,GAAG,GAAG,MAAM,GAAG,MAAM,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,MAAM,EAAE,CAAC;IAClG,IAAA,eAAO,EAAC,QAAQ,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IACnC,+DAA+D;IAC/D,OAAO,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;AACnC,CAAC;AAED,mBAAmB;AACnB,wBAAwB;AACxB,0CAA0C;AAC1C,mBAAmB;AACnB,sCAAsC;AACtC,+BAA+B;AAC/B,gBAAgB;AAChB,YAAY;AACZ,QAAQ;AACR,IAAI;AACJ,mBAAmB;AACnB,wBAAwB;AACxB,0CAA0C;AAC1C,uBAAuB;AACvB,QAAQ;AACR,IAAI;AAGJ,wBAAwB;AACxB,8CAA8C;AAC9C,oEAAoE;AACpE,IAAI;AAGJ,mDAAmD;AACnD,wHAAwH;AACxH,yDAAyD","sourcesContent":["import { logInfo } from \"../LogTS\";\r\n\r\n\r\n//该代码没有被使用，查找解码的时候，请查看 protocol.ts\r\n\r\n/** 配置编解码 */\r\nexport function getEncodeDecodeFunc(): { \"msgEncode\": (mainKey: number, sonKey: number, data: any, toS: boolean) => Buffer, \"msgDecode\": (mainKey: number, sonKey: number, msg: Buffer, toS: boolean) => any } {\r\n    return { \"msgEncode\": msgEncode, \"msgDecode\": msgDecode };\r\n}\r\n\r\nfunction msgDecode(mainKey: number, sonKey: number, msgBuf: Buffer, toS: boolean): any {\r\n    // let msg = msgCoder[cmdId].c2s?.decode(msgBuf);\r\n    // logInfo(\"--->>>\", app.routeConfig[cmdId], JSON.stringify(msg));\r\n    // return msg;\r\n    let rlanlu = global[\"lanlu\"];\r\n    let ptName = 'Pt' + mainKey.toString() + '_' + sonKey + '_tos';\r\n    logInfo(\"--->>>\", mainKey, sonKey, ptName, msgBuf);\r\n    let jsonData: any = rlanlu[ptName].decode(msgBuf);\r\n    return jsonData;\r\n}\r\n\r\nfunction msgEncode(mainKey: number, sonKey: number, data: any, toS: boolean): Buffer {\r\n    let rlanlu = global[\"lanlu\"];\r\n    let encodeData: Uint8Array = rlanlu['Pt' + mainKey + '_' + sonKey + '_toc'].encode(data).finish();\r\n    logInfo(\"<<<---\", mainKey, sonKey);\r\n    // return msgCoder[cmdId].s2c?.encode(data).finish() as Buffer;\r\n    return Buffer.from(encodeData);\r\n}\r\n\r\n// // 编码时直接中转Buffer\r\n// let encode_buffer = {\r\n//     \"encode\": function (data: Buffer) {\r\n//         return {\r\n//             \"finish\": function () {\r\n//                 return data;\r\n//             }\r\n//         }\r\n//     }\r\n// }\r\n// // 解码时直接中转Buffer\r\n// let decode_buffer = {\r\n//     \"decode\": function (data: Buffer) {\r\n//         return data;\r\n//     }\r\n// }\r\n\r\n\r\n// interface I_msg_con {\r\n//     c2s?: { decode: (msg: Buffer) => any };\r\n//     s2c?: { encode: (msg: any) => { finish: () => Uint8Array } };\r\n// }\r\n\r\n\r\n// let msgCoder: { [cmd: string]: I_msg_con } = {};\r\n// msgCoder[cmd.connector_main_ping] = { \"c2s\": cs_msg.c2s_connector_main_ping, \"s2c\": cs_msg.s2c_connector_main_ping };\r\n// msgCoder[cmd.onHello] = { \"s2c\": cs_msg.s2c_onHello };\r\n\r\n\r\n"]}