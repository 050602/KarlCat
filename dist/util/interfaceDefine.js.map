{"version":3,"file":"interfaceDefine.js","sourceRoot":"","sources":["../../src/util/interfaceDefine.ts"],"names":[],"mappings":"","sourcesContent":["import { EventEmitter } from \"events\";\r\nimport { Application } from \"../application\";\r\nimport { Session } from \"../components/session\";\r\nimport { ServerName } from \"../serverConfig/route\";\r\n\r\n/**\r\n * socket connection proxy\r\n */\r\nexport interface SocketProxy extends EventEmitter {\r\n    socket: any;\r\n    remoteAddress: string;\r\n    die: boolean;\r\n    maxLen: number;\r\n    len: number;\r\n    buffer: Buffer;\r\n    headLen: number;\r\n    headBuf: Buffer;\r\n    close(): void;\r\n    send(data: Buffer): void;\r\n}\r\n\r\n/**\r\n * The monitor receives the new server information format from the master\r\n */\r\nexport interface monitor_get_new_server {\r\n    \"T\": number;\r\n    \"servers\": {\r\n        [serverName: string]: ServerInfo\r\n    };\r\n}\r\n\r\n/**\r\n * The monitor receives the removal server information format from the master\r\n */\r\nexport interface monitor_remove_server {\r\n    \"T\": number;\r\n    \"serverName\": string;\r\n    \"serverType\": string;\r\n}\r\n\r\n/**\r\n * The message format when the monitor registers with the master\r\n */\r\nexport interface monitor_reg_master {\r\n    T: number,\r\n    serverToken?: string,\r\n    cliToken?: string,\r\n    serverInfo: ServerInfo\r\n}\r\n\r\n/**\r\n * The session copied from the front end to the back end\r\n */\r\nexport interface sessionCopyJson {\r\n    uid: number;\r\n    sid: string;\r\n    settings: { [key: string]: any };\r\n}\r\n\r\n/**\r\n * Internal frame log level\r\n */\r\nexport const enum loggerLevel {\r\n    info = \"info\",\r\n    warn = \"warn\",\r\n    error = \"error\"\r\n}\r\n\r\n/**\r\n * Internal frame log type\r\n */\r\nexport const enum loggerType {\r\n    frame = \"frame\",\r\n    msg = \"msg\",\r\n}\r\n\r\n\r\n\r\n/**\r\n * rpc message-oriented package\r\n * 1. If there is cmd and id, it means the message is received and needs to be called back\r\n * 2. With cmd without id means no need to call back when the message is received\r\n * 3. If there is an id without cmd, it means it is a callback message\r\n * 4. len represents the length of the last Buffer parameter\r\n */\r\nexport interface I_rpcMsg {\r\n    cmd?: string;\r\n    id?: number;\r\n    len?: number;\r\n}\r\n\r\n/**\r\n * rpc request timeout\r\n */\r\nexport interface I_rpcTimeout {\r\n    id: number;\r\n    cb: Function;\r\n    await: boolean;\r\n    time: number;\r\n}\r\n\r\n\r\nexport interface I_someConfig {\r\n    \"rpc\": I_rpcConfig,             // rpc configuration\r\n    \"connector\": I_connectorConfig, // Front-end connector connection server configuration\r\n    \"encodeDecode\": I_encodeDecodeConfig,   // Codec configuration\r\n    \"ssh\": string[],                // ssh configuration\r\n    \"recognizeToken\": { \"serverToken\": string, \"cliToken\": string },    // Authentication key\r\n    \"logger\": (type: loggerType, level: loggerLevel, msg: string) => void,           // Internal log output\r\n    \"mydogList\": () => { \"title\": string, \"value\": string }[],      // Custom monitoring\r\n    \"onBeforeExit\": (cb: () => void) => void,       // beforeExit notice\r\n    \"onMydogSend\": (args: string[], cb: (data: any) => void) => void,       // mydog send msg callback\r\n}\r\n\r\n/**\r\n * Connect the user's socket management agent\r\n */\r\nexport interface I_clientManager {\r\n    addClient(client: I_clientSocket): void;\r\n    handleMsg(client: I_clientSocket, msg: Buffer): void;\r\n    removeClient(client: I_clientSocket): void;\r\n}\r\n\r\n/**\r\n * Connection server constructor\r\n */\r\nexport interface I_connectorConstructor {\r\n    new(info: { app: Application, clientManager: I_clientManager, config: I_connectorConfig, startCb: () => void }): void;\r\n}\r\n\r\n/**\r\n * Socket for each user\r\n */\r\nexport interface I_clientSocket {\r\n    session: Session;\r\n    remoteAddress: string;\r\n    send(msg: Buffer): void;\r\n    close(): void;\r\n}\r\n\r\n\r\n\r\n/**\r\n * connector configuration\r\n */\r\nexport interface I_connectorConfig {\r\n    /**\r\n     * custom connector class (default tcp)\r\n     */\r\n    \"connector\"?: I_connectorConstructor,\r\n    /**\r\n     * heartbeat (seconds, default none)\r\n     */\r\n    \"heartbeat\"?: number,\r\n    /**\r\n     * maximum number of connections (no upper limit by default)\r\n     */\r\n    \"maxConnectionNum\"?: number,\r\n    /**\r\n     * maximum message packet length (default 10 MB)\r\n     */\r\n    \"maxLen\"?: number\r\n    /**\r\n     * whether to enable Nagle algorithm (not enabled by default)\r\n     */\r\n    \"noDelay\"?: boolean,\r\n    /**\r\n     * message sending frequency (ms, more than 10 is enabled, the default is to send immediately)\r\n     */\r\n    \"interval\"?: number,\r\n    /**\r\n     * client connection notification\r\n     */\r\n    \"clientOnCb\"?: (session: Session) => void,\r\n    /**\r\n     * client leaving notification\r\n     */\r\n    \"clientOffCb\"?: (session: Session) => void,\r\n    /**\r\n     * message filtering. Return true, the message will be discarded.\r\n     */\r\n    \"cmdFilter\"?: (session: Session, cmd: number) => boolean,\r\n\r\n    [key: string]: any,\r\n}\r\n\r\n\r\n/**\r\n * codec configuration\r\n */\r\nexport interface I_encodeDecodeConfig {\r\n    /**\r\n     * protocol encoding\r\n     */\r\n    \"protoEncode\"?: (mainKey: number, sonKey: number, msg: any, toS: boolean) => Buffer,\r\n    /**\r\n     * message encoding\r\n     */\r\n    \"msgEncode\"?: (mainKey: number, sonKey: number, msg: any, toS: boolean) => Uint8Array,\r\n    /**\r\n     * protocol decoding\r\n     */\r\n    \"protoDecode\"?: (data: Buffer) => { mainKey: number, sonKey: number, \"msg\": Buffer, toS: boolean },\r\n    /**\r\n     * message decoding\r\n     */\r\n    \"msgDecode\"?: (mainKey: number, sonKey: number, msg: Buffer, toS: boolean) => any,\r\n}\r\n\r\n\r\n/**\r\n * rpc configuration\r\n */\r\nexport interface I_rpcConfig {\r\n    /**\r\n     * timeout (seconds, use more than 5, default 10)\r\n     */\r\n    \"timeout\"?: number,\r\n    /**\r\n     * maximum message packet length (default 10 MB)\r\n     */\r\n    \"maxLen\"?: number,\r\n    /**\r\n     * message sending frequency (ms, more than 10 is enabled, the default is to send immediately)\r\n     */\r\n    \"interval\"?: number | { \"default\": number, [serverType: string]: number }\r\n    /**\r\n     * whether to enable Nagle algorithm (not enabled by default)\r\n     */\r\n    \"noDelay\"?: boolean,\r\n    /**\r\n     * heartbeat (seconds, use more than 5, default 60)\r\n     */\r\n    \"heartbeat\"?: number,\r\n    /**\r\n     * reconnection interval (seconds, default 2)\r\n     */\r\n    \"reconnectDelay\"?: number,\r\n    /**\r\n     * matrix without socket connection\r\n     */\r\n    \"noRpcMatrix\"?: { [serverType: string]: string[] },\r\n    /**\r\n    * Message cache length. The default is 5000.\r\n    */\r\n    \"msgCacheLength\"?: number,\r\n}\r\n\r\n\r\n/**\r\n * server information\r\n */\r\nexport interface ServerInfo {\r\n    //数字ID\r\n    readonly serverId: number;\r\n    /**\r\n     * Server id 即服务器唯一名称\r\n     */\r\n    readonly serverName: string;\r\n    /**\r\n     * host\r\n     */\r\n    readonly host: string;\r\n    /**\r\n     * port\r\n     */\r\n    readonly port: number;\r\n    /**\r\n     * Is it a frontend server\r\n     */\r\n    readonly frontend: boolean;\r\n    /**\r\n     * clientPort\r\n     */\r\n    readonly clientPort: number;\r\n    /**\r\n     * Server type [Note: Assigned by the framework]  服务器类型  Gate  Logic之类\r\n     */\r\n    readonly serverType: ServerName;\r\n\r\n    [key: string]: any;\r\n}\r\n\r\n/**\r\n * rpc call, internal error code\r\n */\r\nexport const enum rpcErr {\r\n    /**\r\n     * no err\r\n     */\r\n    ok = 0,\r\n    /**\r\n     * no target server\r\n     */\r\n    noServer = 1,\r\n    /**\r\n     * rpc timeout\r\n     */\r\n    timeout = 2\r\n}"]}