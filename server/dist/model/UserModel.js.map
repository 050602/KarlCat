{"version":3,"file":"UserModel.js","sourceRoot":"","sources":["../../src/model/UserModel.ts"],"names":[],"mappings":";;;;;;AAAA,0DAAiC;AACjC,gCAA6B;AAE7B,iEAA8D;AAC9D,6CAA+C;AAC/C,2CAAwC;AAGxC,iBAAiB;AACjB,MAAa,SAAU,SAAQ,qBAAS;IAE7B,MAAM,KAAK,QAAQ;QACtB,OAAO,IAAI,CAAC,WAAW,EAAE,CAAC;IAC9B,CAAC;IAEM,YAAY;QACf,oEAAoE;QACpE,IAAI,OAAO,GAAG;YACV,yDAAyD;YACzD,GAAG,EAAE,IAAI,GAAG,EAAE,GAAG,CAAC;YAClB,YAAY,EAAE,IAAI;YAClB,uBAAuB;YACvB,UAAU,EAAE,KAAK;YACjB,cAAc,EAAE,IAAI;YACpB,cAAc,EAAE,KAAK;YACrB,gBAAgB,EAAE,IAAI;YACtB,4FAA4F;YAC5F,WAAW,EAAE,+BAAc,CAAC,QAAQ,CAAC,SAAS;YAC9C,YAAY,EAAE,+BAAc,CAAC,QAAQ;SACxC,CAAA;QAED,IAAI,CAAC,aAAa,GAAG,IAAI,mBAAQ,CAAC,OAAO,CAAC,CAAC;QAE3C,eAAe;QACf,IAAI,SAAG,CAAC,UAAU,IAAI,kBAAU,CAAC,IAAI,EAAE;YACnC,IAAI,QAAQ,GAAG;gBACX,yDAAyD;gBACzD,GAAG,EAAE,IAAI,GAAG,EAAE;gBACd,YAAY,EAAE,IAAI;gBAClB,uBAAuB;gBACvB,UAAU,EAAE,KAAK;gBACjB,cAAc,EAAE,IAAI;gBACpB,cAAc,EAAE,KAAK;gBACrB,gBAAgB,EAAE,IAAI;gBACtB,4FAA4F;gBAC5F,WAAW,EAAE,+BAAc,CAAC,QAAQ,CAAC,eAAe;gBACpD,YAAY,EAAE,+BAAc,CAAC,QAAQ;aACxC,CAAA;YACD,IAAI,CAAC,kBAAkB,GAAG,IAAI,mBAAQ,CAAC,QAAQ,CAAC,CAAA;SACnD;IACL,CAAC;IAAA,CAAC;IAMK,eAAe;IACtB,CAAC;IAAA,CAAC;IAGK,KAAK,CAAC,MAAM,CAAC,IAAc;QAC9B,OAAO,KAAK,CAAC,SAAS,CAAC,IAAI,CAAC,CAAC;IACjC,CAAC;IAEM,KAAK,CAAC,IAAI,CAAC,QAAgB;QAC9B,OAAO,KAAK,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;IACnC,CAAC;IAGM,KAAK,CAAC,aAAa,CAAC,OAAe;QACtC,OAAO,KAAK,CAAC,eAAe,CAAC,EAAE,OAAO,EAAE,OAAO,EAAE,CAAC,CAAC;IACvD,CAAC;IAED;;;;;OAKG;IACI,KAAK,CAAC,YAAY,CAAC,IAAS;QAC/B,OAAO,KAAK,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;IACvC,CAAC;IAGM,KAAK,CAAC,YAAY,CAAC,IAAS;QAC/B,OAAO,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,CAAC;IAC/B,CAAC;IAEM,KAAK,CAAC,SAAS,CAAC,QAAgB;QACnC,OAAO,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAQ,CAAC;IAC5C,CAAC;IAEM,KAAK,CAAC,MAAM,CAAC,QAAgB,EAAE,IAAS;QAC3C,OAAO,KAAK,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;IAC3C,CAAC;;AArFL,8BAuFC;AAtFiB,yBAAe,GAAG,WAAW,CAAC","sourcesContent":["import LRUCache from \"lru-cache\";\r\nimport { app } from \"../app\";\r\nimport { UserData } from \"../database/UserTable\";\r\nimport { UserModelLogic } from \"../modelLogic/UserModelLogic\";\r\nimport { ServerType } from \"../register/route\";\r\nimport { BaseModel } from \"./BaseModel\";\r\n\r\n\r\n//请不要在Model里写任何逻辑\r\nexport class UserModel extends BaseModel {\r\n    public static SigletonInsName = \"UserModel\";\r\n    public static get Instance(): UserModel {\r\n        return this.getInstance();\r\n    }\r\n\r\n    public initInstance() {\r\n        //新增的缓存，需要在RoleRpcMain 的 updateOnlineCache 方法处理一次get 避免因为在线很久，把缓存清除了\r\n        let options = {\r\n            // max: 3333,//最大缓存条数,理论上按同时在线玩家的2倍处理即可？理论上单服3000人，那就6000\r\n            ttl: 1000 * 60 * 5,//存活多久 毫秒 如果启用了ttl ，Has判断过期Item时，总是会返回false\r\n            ttlAutopurge: true,\r\n            //在从缓存中移除之前返回过期的项目? LRU\r\n            allowStale: false,//如果设置了ttl,当调用get时，是否返回过期的item\r\n            updateAgeOnGet: true,//如果设置了ttl,当调用get时，是否更新过期时间戳\r\n            updateAgeOnHas: false,//如果设置了ttl,当调用has时，是否更新过期时间戳\r\n            ignoreFetchAbort: true,//忽略淘汰时的异常中止\r\n            //如果缓存中没有指定值，调用cache.fetch时，会调用以下方法，并把方法的返回值，返回,,,就是说，如果缓存中存在，是不会调用该方法的; ps:该方法会自动把返回值设置进缓存内\r\n            fetchMethod: UserModelLogic.Instance.fetchData,//该方法是异步的才对，理论上传进来的方法需要是async\r\n            fetchContext: UserModelLogic.Instance,\r\n        }\r\n\r\n        this.userDataCache = new LRUCache(options);\r\n\r\n        //在gate时，缩短缓存时间\r\n        if (app.serverType == ServerType.gate) {\r\n            let options2 = {\r\n                // max: 8000,//最大缓存条数,理论上按同时在线玩家的2倍处理即可？理论上单服3000人，那就6000\r\n                ttl: 1000 * 10,//存活多久 毫秒 如果启用了ttl ，Has判断过期Item时，总是会返回false\r\n                ttlAutopurge: true,\r\n                //在从缓存中移除之前返回过期的项目? LRU\r\n                allowStale: false,//如果设置了ttl,当调用get时，是否返回过期的item\r\n                updateAgeOnGet: true,//如果设置了ttl,当调用get时，是否更新过期时间戳\r\n                updateAgeOnHas: false,//如果设置了ttl,当调用has时，是否更新过期时间戳\r\n                ignoreFetchAbort: true,//忽略淘汰时的异常中止\r\n                //如果缓存中没有指定值，调用cache.fetch时，会调用以下方法，并把方法的返回值，返回,,,就是说，如果缓存中存在，是不会调用该方法的; ps:该方法会自动把返回值设置进缓存内\r\n                fetchMethod: UserModelLogic.Instance.fetchDataString,//该方法是异步的才对，理论上传进来的方法需要是async\r\n                fetchContext: UserModelLogic.Instance,\r\n            }\r\n            this.userDataLoginCache = new LRUCache(options2)\r\n        }\r\n    };\r\n\r\n    //禁止在逻辑类直接操作该变量 \r\n    public userDataCache: LRUCache<number, UserData>;\r\n    public userDataLoginCache: LRUCache<string, UserData>;\r\n\r\n    public destoryInstance() {\r\n    };\r\n\r\n\r\n    public async insert(data: UserData): Promise<UserData> {\r\n        return super.insertOne(data);\r\n    }\r\n\r\n    public async find(username: string): Promise<UserData> {\r\n        return super.findOne(username);\r\n    }\r\n\r\n\r\n    public async findByRoleUid(roleUid: number): Promise<UserData> {\r\n        return super.findOneByObject({ roleUid: roleUid });\r\n    }\r\n\r\n    /**\r\n     * 该方法理论上跟findOne一毛一样，主要用来区分findOne ,让 findOne可以用单一key做Map缓存\r\n     * 此处不能直接调用findOne  因为在子类时，会调用到子类的findOne 该方法无法保证取到最新的数据，因为数据需要落地\r\n     * @param cond\r\n     * @returns \r\n     */\r\n    public async findByObject(cond: any): Promise<UserData> {\r\n        return super.findOneByObject(cond);\r\n    }\r\n\r\n\r\n    public async findAllByAny(cond: any): Promise<UserData[]> {\r\n        return super.findAll(cond);\r\n    }\r\n\r\n    public async deleteOne(username: string): Promise<boolean> {\r\n        return super.deleteOne(username) as any;\r\n    }\r\n\r\n    public async update(userName: string, data: any): Promise<boolean> {\r\n        return super.updateOne(userName, data);\r\n    }\r\n\r\n}"]}