{"version":3,"file":"BaseModel.js","sourceRoot":"","sources":["../../src/model/BaseModel.ts"],"names":[],"mappings":";;;AAAA,gCAA6B;AAC7B,+CAA4C;AAC5C,0DAAuD;AACvD,6CAA+C;AAqB/C,iBAAiB;AACjB,MAAa,SAAU,SAAQ,mBAAQ;IAMnC,SAAS;IACF,YAAY;QACf,KAAK,CAAC,YAAY,EAAE,CAAC;QACrB,IAAI,CAAC,IAAI,CAAC,SAAS;YACf,IAAI,CAAC,SAAS,GAAG,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IAChE,CAAC;IAAA,CAAC;IAEQ,KAAK,CAAC,SAAS,CAAC,IAAS;QAC/B,oEAAoE;QACpE,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC7F,CAAC;IAES,KAAK,CAAC,OAAO,CAAC,IAAS;QAC7B,kEAAkE;QAClE,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC3F,CAAC;IAGD;;;;;OAKG;IACO,KAAK,CAAC,eAAe,CAAC,IAAS;QACrC,4EAA4E;QAC5E,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,qBAAqB,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACnG,CAAC;IAGS,KAAK,CAAC,OAAO,CAAC,IAAS;QAC7B,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,aAAa,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC3F,CAAC;IAES,KAAK,CAAC,SAAS,CAAC,IAAS,EAAE,IAAS;QAC1C,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;IACnG,CAAC;IAES,KAAK,CAAC,SAAS,CAAC,IAAS;QAC/B,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,eAAe,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IAC7F,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,QAAQ,CAAC,IAAS;QAC9B,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,OAAO,GAAG,IAAI,CAAC,SAAS,EAAE,IAAI,CAAC,CAAC;IACrF,CAAC;IAED;;OAEG;IACO,KAAK,CAAC,YAAY,CAAC,KAAa,EAAE,IAAS;QACjD,OAAO,SAAG,CAAC,KAAK,CAAC,SAAS,CAAC,MAAM,EAAE,6BAAa,CAAC,UAAU,GAAG,IAAI,CAAC,SAAS,EAAE,KAAK,EAAE,IAAI,CAAC,CAAC;IAC/F,CAAC;;AA5DL,8BA6DC;AA3DG,iBAAiB;AACA,gBAAM,GAAW,kBAAU,CAAC,QAAQ,GAAG,IAAI,CAAC","sourcesContent":["import { app } from \"../app\";\r\nimport { Sigleton } from \"../core/Sigleton\";\r\nimport { DatabaseEvent } from \"../event/DatabaseEvent\";\r\nimport { ServerType } from \"../register/route\";\r\n\r\nexport interface LRUOptions {\r\n    max?: number,//最大缓存条数,理论上按同时在线玩家的2倍处理即可？理论上单服3000人，那就6000\r\n    dispose?: any,\r\n    //  (value, key) => {\r\n    //     // freeFromMemoryOrWhatever(value)\r\n    // },//当缓存被删除时，执行的回调方法\r\n    ttl?: number,//存活多久 毫秒 如果启用了ttl ，Has判断过期Item时，总是会返回false\r\n    ttlAutopurge?: boolean,\r\n    //在从缓存中移除之前返回过期的项目? LRU\r\n    allowStale: boolean,//如果设置了ttl,当调用get时，是否返回过期的item\r\n    updateAgeOnGet: boolean,//如果设置了ttl,当调用get时，是否更新过期时间戳\r\n    updateAgeOnHas: boolean,//如果设置了ttl,当调用has时，是否更新过期时间戳\r\n    //如果缓存中没有指定值，调用cache.fetch时，会调用以下方法，并把方法的返回值，返回,,,就是说，如果缓存中存在，是不会调用该方法的\r\n    //参数分别为 key,可能是过期值（都获取不到了，为啥还会有旧的值？怀疑是过期值），｛不需要，不需要，上下文(就是下面的fetchContext)｝\r\n    fetchMethod?: any//该方法是异步的才对，理论上传进来的方法需要是async\r\n    fetchContext?: any,//上下文,使用fetchMethod可能会使用到\r\n    ignoreFetchAbort?: boolean,\r\n}\r\n\r\n//请不要在Model里写任何逻辑\r\nexport class BaseModel extends Sigleton {\r\n    public tableName: string;\r\n    //请不要在Model里写任何逻辑\r\n    protected static dbName: string = ServerType.database + \"-1\";\r\n\r\n\r\n    //当实例初始化时\r\n    public initInstance() {\r\n        super.initInstance();\r\n        if (!this.tableName)\r\n            this.tableName = this.clsName.replace('Model', 'Table');\r\n    };\r\n\r\n    protected async insertOne(data: any): Promise<any> {\r\n        // console.log('in base model, insert one, table:', this.tableName);\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnInsertOneData + this.tableName, data);\r\n    }\r\n\r\n    protected async findOne(cond: any): Promise<any> {\r\n        // console.log('in base model, find one, table:', this.tableName);\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnFindOneData + this.tableName, cond);\r\n    }\r\n\r\n\r\n    /**\r\n     * 该方法理论上跟findOne一毛一样，主要用来区分findOne ,让 findOne可以用单一key做Map缓存\r\n     * 此处不能直接调用findOne  因为在子类时，会调用到子类的findOne\r\n     * @param cond\r\n     * @returns \r\n     */\r\n    protected async findOneByObject(cond: any): Promise<any> {\r\n        // console.log('in base model, find one by object, table:', this.tableName);\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnFindOneDataByObject + this.tableName, cond);\r\n    }\r\n\r\n\r\n    protected async findAll(cond: any): Promise<any[]> {\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnFindAllData + this.tableName, cond);\r\n    }\r\n\r\n    protected async updateOne(cond: any, data: any): Promise<boolean> {\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnUpdateOneData + this.tableName, cond, data);\r\n    }\r\n\r\n    protected async deleteOne(cond: any): Promise<boolean> {\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnDeleteOneData + this.tableName, cond);\r\n    }\r\n\r\n    /**\r\n     * 统计数量\r\n     */\r\n    protected async countNum(cond: any):Promise<number> {\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnCount + this.tableName, cond);\r\n    }\r\n\r\n    /**\r\n     * 获取唯一字段列表\r\n     */\r\n    protected async distinctList(field: string, cond: any): Promise<any> {\r\n        return app.rpcDB(BaseModel.dbName, DatabaseEvent.OnDistinct + this.tableName, field, cond);\r\n    }\r\n}"]}