{"version":3,"file":"JPSPlus.js","sourceRoot":"","sources":["../../src/utils/JPSPlus.ts"],"names":[],"mappings":"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","sourcesContent":["// import { gzaLog } from \"../LogTS\";\r\n// import { IObjectPool } from \"../core/IObjectPool\";\r\n// import { ObjectPool } from \"../core/ObjectPool\";\r\n// import { MapData } from \"../servers/Fight/map/MapData\";\r\n\r\n\r\n// /**\r\n//  * 可走标识\r\n//  */\r\n// export let PATH_FLAG = true;\r\n\r\n// class PathInfo implements IObjectPool {\r\n//     x: number;\r\n//     y: number;\r\n\r\n//     /**\r\n//      * 周围节点\r\n//      */\r\n//     links: PathInfo[] = [];\r\n//     parent: PathInfo;\r\n\r\n//     // constructor(nowPos: any, parent: PathInfo) {\r\n//     //     this.dataInit(nowPos, parent);\r\n//     // }\r\n//     inPool: boolean;\r\n//     onRecycled(): void {\r\n//         // for (let i = 0; i < this.links.length; i++) {\r\n//         //     ObjectPool.recycle(this.links[i]);\r\n//         // }\r\n//         this.links = [];\r\n//         this.parent = null\r\n//     }\r\n\r\n//     // dataInit(nowPos: PathInfo, parent: PathInfo) {\r\n//     //     this.x = nowPos.x;\r\n//     //     this.y = nowPos.y;\r\n//     //     // this.links = [];\r\n//     //     this.parent = parent;\r\n//     // };\r\n// }\r\n\r\n\r\n// //垂直版本JPSPlus\r\n// export class JPSPlus {\r\n\r\n//     // public static mapWidth: number = 0;\r\n//     // public static mapHeight: number = 0;\r\n\r\n//     // public static init(mapWidth: number, mapHeight: number) {\r\n//     //     mapHeight = mapHeight;\r\n//     //     mapWidth = mapWidth;\r\n//     // }\r\n\r\n//     public static find(mapData: MapData, mapWidth: number, mapHeight: number, map: boolean[], startX: number, startY: number, endX: number, endY: number): number[] {\r\n//         // jumpPointXY.clear();\r\n//         let jumpPointXY: Map<number, number[]> = new Map();\r\n//         let open: PathInfo[] = [];\r\n//         let close: Map<number, boolean> = new Map();\r\n//         let tempMap = map.concat([]);\r\n//         let index1 = mapWidth * startY + startX;\r\n//         tempMap[index1] = true;\r\n//         // tempMap = tempMap;\r\n//         // endX = endX;\r\n//         // endY = endY;\r\n//         // open = [];\r\n//         // close.clear();\r\n//         let index2 = mapWidth * endY + endX;\r\n//         jumpPointXY.set(index2, [endX, endY]);\r\n//         jumpPointXY.set(index1, [startX, startY]);\r\n//         let arr = this.findReal(mapData, mapWidth, mapHeight, map, tempMap, jumpPointXY, open, close, startX, startY, endX, endY, false);\r\n//         for (let i = 0; i < open.length; i++) {\r\n//             ObjectPool.recycle(open[i]);\r\n//         }\r\n\r\n//         return arr;\r\n//     }\r\n\r\n//     // private static isPassable(mapData: MapData, mapWidth: number, mapHeight: number, map: boolean[], tempMap: boolean[], jumpPointXY: Map<number, number[]>, open: PathInfo[], close: Map<number, boolean>, startX: number, startY: number, endX: number, endY: number): boolean {\r\n//     //     let path = this.findReal(mapData, mapWidth, mapHeight, map, tempMap, jumpPointXY, open, close, startX, startY, endX, endY, true);\r\n//     //     if (path && path.length)\r\n//     //         return true;\r\n//     //     return false;\r\n//     // }\r\n\r\n\r\n//     // private static jumpPointXY: Map<number, number[]> = new Map();\r\n//     // private static tempMap: boolean[];\r\n//     // private static endX: number = 0;\r\n//     // private static endY: number = 0;\r\n//     // private static startX: number = 0;\r\n//     // private static startY: number = 0;\r\n//     // private static close: Map<number, boolean> = new Map();\r\n//     // private static open: PathInfo[];\r\n\r\n//     //从起点开始搜索\r\n//     private static findReal(mapData: MapData, mapWidth: number, mapHeight: number, map: boolean[], tempMap: boolean[], jumpPointXY: Map<number, number[]>, open: PathInfo[], close: Map<number, boolean>, startX: number, startY: number, endX: number, endY: number, isTwo = false): number[] {\r\n//         // let path = new PathInfo({ x: startX, y: startY }, null);\r\n//         let path = ObjectPool.get(PathInfo);\r\n//         path.x = startX;\r\n//         path.y = startY;\r\n\r\n//         let index1 = mapWidth * endY + endX;\r\n//         if (!map[index1]) {\r\n//             if (!isTwo) {\r\n//                 if (Math.abs(startX - endX) + Math.abs(startY - endY) <= 1) {\r\n//                     return null;\r\n//                 }\r\n//                 let replace = this.findNearest(mapWidth, mapHeight, map, startX, startY, endX, endY);\r\n//                 if (replace) {\r\n//                     for (let i = 0; i < replace.length; i++) {\r\n//                         let XY = mapData.getXYByIndex(replace[i]);\r\n//                         let newReturn = this.findReal(mapData, mapWidth, mapHeight, map, tempMap, jumpPointXY, open, close, startX, startY, XY[0], XY[1], true);\r\n//                         if (newReturn != null) {\r\n//                             // newReturn = JPSPlus.pruning2(tempMap, newReturn);\r\n//                             return newReturn;\r\n//                         }\r\n//                     }\r\n//                 }\r\n//             }\r\n//             gzaLog(\"JPSPlus 未找到出口1\");\r\n//             return null;\r\n//         }\r\n\r\n//         open.push(path);\r\n\r\n//         let canRunPath: number[][] = [];\r\n//         let runCount: number = 0;\r\n//         while (true) {\r\n//             runCount++;\r\n//             if (canRunPath.length > 3 || (canRunPath.length > 1 && runCount > 100) || !open.length) {\r\n//                 if (canRunPath.length) {\r\n//                     canRunPath.sort((a: number[], b: number[]) => {\r\n//                         return a.length - b.length\r\n//                     });\r\n\r\n//                     // log(\"JPS运行次数\", runCount);\r\n//                     return canRunPath[0];\r\n//                 }\r\n//                 return null;\r\n//             }\r\n\r\n\r\n\r\n//             let nowPath: PathInfo = open[0];\r\n//             // let pppp = \"\";\r\n//             // for (let i = 0; i < open.length; i++) {\r\n//             //     pppp += open[i].x + \"_\" + open[i].y + \"  \";\r\n//             // }\r\n//             // log(\"pppp\", pppp);\r\n//             open.splice(0, 1); //清除已经走过的格子\r\n//             close.set(nowPath.x * 1000 + nowPath.y, true);\r\n//             if (nowPath.x == endX && nowPath.y == endY) {\r\n//                 let path = JPSPlus.reversePath(nowPath);\r\n//                 JPSPlus.pruning(mapData, tempMap, path);\r\n//                 // path = JPSPlus.pruning(tempMap, path);\r\n//                 let newPath = this.JumpPointToFullPath(mapWidth, mapHeight, path);\r\n//                 if (!map[index1]) {\r\n//                     newPath.splice(newPath.length - 1, 1);\r\n//                 }\r\n//                 // gzaLog(\"JPSPlus path\", newPath);\r\n//                 canRunPath.push(newPath);\r\n//                 continue;\r\n//                 // return newPath;\r\n//             }\r\n//             if (!nowPath.links.length) {\r\n//                 JPSPlus.jumpToFind(mapData, mapWidth, mapHeight, tempMap, jumpPointXY, close, nowPath, endX, endY);\r\n//             }\r\n//             let links = nowPath.links;\r\n//             for (let i = 0; i < links.length; i++) {\r\n//                 let line = links[i];\r\n//                 if (line.x == endX && line.y == endY) {\r\n//                     let path = JPSPlus.reversePath(line);\r\n//                     JPSPlus.pruning(mapData, tempMap, path);\r\n//                     // path = JPSPlus.pruning(tempMap, path);\r\n//                     let newPath = this.JumpPointToFullPath(mapWidth, mapHeight, path);\r\n//                     let index1 = mapWidth * endY + endX;\r\n//                     if (!map[index1]) {\r\n//                         newPath.splice(newPath.length - 1, 1);\r\n//                     }\r\n//                     // return newPath;\r\n//                     // gzaLog(\"JPSPlus path\", newPath);\r\n\r\n//                     canRunPath.push(newPath);\r\n//                     continue;\r\n//                 }\r\n\r\n//                 if (!JPSPlus.openIndexOf(open, line)) {\r\n//                     //判断是否存在open列表\r\n//                     open.push(line);\r\n//                 }\r\n//             }\r\n\r\n//             if (!open.length) {\r\n//                 if (canRunPath.length) {\r\n//                     canRunPath.sort((a: number[], b: number[]) => {\r\n//                         return a.length - b.length\r\n//                     });\r\n//                     // log(\"JPS运行次数==\", runCount);\r\n//                     return canRunPath[0];\r\n//                 }\r\n\r\n//                 if (!isTwo) {\r\n//                     let replace = this.findNearest(mapWidth, mapHeight, tempMap, startX, startY, endX, endY);\r\n//                     if (replace) {\r\n//                         for (let i = 0; i < replace.length; i++) {\r\n//                             let XY = mapData.getXYByIndex(replace[i]);\r\n//                             let newReturn = this.findReal(mapData, mapWidth, mapHeight, map, tempMap, jumpPointXY, open, close, startX, startY, XY[0], XY[1], true);\r\n//                             if (newReturn != null) {\r\n//                                 return newReturn;\r\n//                             }\r\n//                         }\r\n//                     }\r\n//                 }\r\n//                 gzaLog(\"JPSPlus 未找到出口2\");\r\n//                 return null;\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     private static pruning(mapData: MapData, tempMap: boolean[], arr: number[][]) {\r\n//         //直线剪枝校验\r\n//         if (arr.length < 3) {\r\n//             return;\r\n//         }\r\n\r\n//         for (let i = 0; i < arr.length - 2; i++) {\r\n//             let k = i + 2;\r\n//             if (arr[i + 1][0] == arr[k][0]) {\r\n//                 if (JPSPlus.isStraightLine(mapData, tempMap, arr[i], arr[i + 1], arr[k])) {\r\n//                     arr.splice(i + 1, 1);\r\n//                     i--;\r\n//                 }\r\n//             } else if (arr[i + 1][1] == arr[k][1]) {\r\n//                 if (JPSPlus.isStraightLine(mapData, tempMap, arr[i], arr[i + 1], arr[k])) {\r\n//                     arr.splice(i + 1, 1);\r\n//                     i--;\r\n//                 }\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     //判断是否直线\r\n//     private static isStraightLine(mapData: MapData, tempMap: boolean[], nowPos: number[], pos1: number[], pos2: number[]) {\r\n//         let chaX = Math.abs(pos1[0] - pos2[0]);\r\n\r\n//         if (chaX > 1) {\r\n//             if (pos2[0] > pos1[0]) {\r\n//                 for (let i = 1; i <= chaX; i++) {\r\n//                     let index = mapData.getIndexByXY(pos2[0] - i, pos1[1]);\r\n//                     if (!tempMap[index]) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//             } else {\r\n//                 for (let i = 1; i <= chaX; i++) {\r\n//                     let index = mapData.getIndexByXY(pos1[0] - i, pos1[1]);\r\n//                     if (!tempMap[index]) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//             }\r\n//             //判断一下，2-27能否直接不需要 3-27，抵达 3-25\r\n//             if (nowPos[0] == pos2[0] || nowPos[1] == pos2[1]) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n\r\n//         let chaY = Math.abs(pos1[1] - pos2[1]);\r\n//         if (chaY > 1) {\r\n//             if (pos2[1] > pos1[1]) {\r\n//                 for (let i = 1; i <= chaY; i++) {\r\n//                     let index = mapData.getIndexByXY(pos2[0], pos2[1] - i);\r\n//                     if (!tempMap[index]) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//             } else {\r\n//                 for (let i = 1; i <= chaY; i++) {\r\n//                     let index = mapData.getIndexByXY(pos1[0], pos1[1] - i);\r\n//                     if (!tempMap[index]) {\r\n//                         return false;\r\n//                     }\r\n//                 }\r\n//             }\r\n\r\n//             if (nowPos[0] == pos2[0] || nowPos[1] == pos2[1]) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n\r\n//         return false;\r\n//     }\r\n\r\n\r\n//     /**\r\n//      * 检查open是否存在line\r\n//      * @param open\r\n//      * @param line\r\n//      */\r\n//     private static openIndexOf(open: PathInfo[], line: PathInfo) {\r\n//         for (let i = 0; i < open.length; i++) {\r\n//             let tempLine = open[i];\r\n//             if (tempLine.x == line.x && tempLine.y == line.y) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n//         return false;\r\n//     }\r\n\r\n//     /**\r\n//      * 把跳点转换回基本坐标\r\n//      * @param paths 坐标路径\r\n//      * @returns indexArr\r\n//      */\r\n//     private static JumpPointToFullPath(mapWidth: number, mapHeight: number, paths: number[][]): number[] {\r\n//         let newPath = [];\r\n//         for (let i = 0; i < paths.length - 1; i++) {\r\n//             let nowPath = paths[i];\r\n//             let nextPath = paths[i + 1];\r\n\r\n//             if (nowPath[0] == nextPath[0]) {\r\n//                 //X相同,Y不同\r\n//                 if (nowPath[1] > nextPath[1]) {\r\n//                     //从下往上\r\n//                     for (let k = nowPath[1]; k > nextPath[1]; k--) {\r\n//                         let index = mapWidth * k + nowPath[0];\r\n//                         newPath.push(index);\r\n//                     }\r\n//                 } else {\r\n//                     // 从上往下\r\n//                     for (let k = nowPath[1]; k < nextPath[1]; k++) {\r\n//                         let index = mapWidth * k + nowPath[0];\r\n//                         newPath.push(index);\r\n//                     }\r\n//                 }\r\n//             } else {\r\n//                 //Y相同 X不同\r\n//                 if (nowPath[0] > nextPath[0]) {\r\n//                     //从右往左\r\n//                     for (let k = nowPath[0]; k > nextPath[0]; k--) {\r\n//                         let index = mapWidth * nowPath[1] + k;\r\n//                         newPath.push(index);\r\n//                     }\r\n//                 } else {\r\n//                     // 从左往右\r\n//                     for (let k = nowPath[0]; k < nextPath[0]; k++) {\r\n//                         let index = mapWidth * nowPath[1] + k;\r\n//                         newPath.push(index);\r\n//                     }\r\n//                 }\r\n\r\n//             }\r\n//         }\r\n//         let last = paths[paths.length - 1];\r\n//         let lastIndex = mapWidth * last[1] + last[0];\r\n//         newPath.push(lastIndex);\r\n\r\n//         return newPath;\r\n//     }\r\n\r\n\r\n//     /**\r\n//      * 逆推出口\r\n//      * @param endPath\r\n//      */\r\n//     private static reversePath(endPath: PathInfo) {\r\n//         let paths: number[][] = [];\r\n//         let tempPath = endPath;\r\n//         while (tempPath) {\r\n//             paths.unshift([tempPath.x, tempPath.y]);\r\n//             tempPath = tempPath.parent;\r\n//         }\r\n//         // gzaLog(...paths);\r\n//         return paths;\r\n//     }\r\n\r\n//     /**\r\n//      * 寻找最近的一个可走格子 只找当前 前后左右  效率对比更高\r\n//      * @param map 路径\r\n//      * @param startX 起点\r\n//      * @param startY 起点\r\n//      * @param endX 终点\r\n//      * @param endY 终点\r\n//      * @returns 最近的可走格子\r\n//      */\r\n//     private static findNearest(mapWidth: number, mapHeight: number, map: boolean[], startX: number, startY: number, endX: number, endY: number): number[] {\r\n//         let arr: any[] = [];\r\n\r\n//         let newx = endX + 1;\r\n//         let newy = endY;\r\n//         let index = mapWidth * newy + newx;\r\n\r\n//         if (!map[index] || (newx == startX && newy == startY) || (newx == endX && newy == endY)) {\r\n//         } else {\r\n//             let quan = Math.abs(startX - newx) + Math.abs(startY - newy);\r\n//             arr.push({ quan: quan, index: index, x: newx, y: newy });\r\n//         }\r\n\r\n//         newx = endX;\r\n//         newy = endY + 1;\r\n//         index = mapWidth * newy + newx;\r\n\r\n//         if (!map[index] || (newx == startX && newy == startY) || (newx == endX && newy == endY)) {\r\n//         } else {\r\n//             let quan = Math.abs(startX - newx) + Math.abs(startY - newy);\r\n//             arr.push({ quan: quan, index: index, x: newx, y: newy });\r\n//         }\r\n\r\n//         newx = endX - 1;\r\n//         newy = endY;\r\n//         index = mapWidth * newy + newx;\r\n\r\n//         if (!map[index] || (newx == startX && newy == startY) || (newx == endX && newy == endY)) {\r\n//         } else {\r\n//             let quan = Math.abs(startX - newx) + Math.abs(startY - newy);\r\n//             arr.push({ quan: quan, index: index, x: newx, y: newy });\r\n//         }\r\n\r\n\r\n//         newx = endX;\r\n//         newy = endY - 1;\r\n//         index = mapWidth * newy + newx;\r\n//         if (!map[index] || (newx == startX && newy == startY) || (newx == endX && newy == endY)) {\r\n//         } else {\r\n//             let quan = Math.abs(startX - newx) + Math.abs(startY - newy);\r\n//             arr.push({ quan: quan, index: index, x: newx, y: newy });\r\n//         }\r\n\r\n\r\n//         arr = arr.sort((a: any, b: any) => {\r\n//             return a.quan - b.quan;\r\n//         });\r\n\r\n//         if (arr.length) {\r\n//             let arr2 = [];\r\n//             for (let i = 0; i < arr.length; i++) {\r\n//                 arr2.push(arr[i].index);\r\n//             }\r\n\r\n//             return arr2;\r\n//         } else {\r\n//             return null;\r\n//         }\r\n//     }\r\n\r\n//     /**\r\n//  * 寻找最近的 往各个位置伸展 效率对比更低\r\n//  * @param map\r\n//  * @param startPos\r\n//  * @param endPos\r\n//  * @param deep\r\n//  */\r\n//     private static findNearest2(mapWidth: number, mapHeight: number, map: boolean[], startX: number, startY: number, endX: number, endY: number): number {\r\n//         let chax = endX - startX;\r\n//         let chay = endY - startY;\r\n//         let xcount = Math.abs(chax);\r\n//         let ycount = Math.abs(chay);\r\n//         let xPlus = 0;\r\n//         if (xcount > 0) xPlus = chax / xcount;\r\n//         let yPlus = 0;\r\n//         if (ycount > 0) yPlus = chay / ycount;\r\n//         let arr: any[] = [];\r\n//         // gzaLog(\"what===\", chax, chay, xcount, ycount, xPlus, yPlus);\r\n//         for (let i = 0; i < xcount + 1; i++) {\r\n//             for (let k = 0; k < ycount + 1; k++) {\r\n//                 let newx = startX + xPlus * i;\r\n//                 let newy = startY + yPlus * k;\r\n//                 let index = mapWidth * newy + newx;\r\n//                 // gzaLog(\"====\", newx, newy, index, i + k, map[index]);\r\n//                 if (!map[index] || (newx == startX && newy == startY) || (newx == endX && newy == endY)) {\r\n//                     continue;\r\n//                 }\r\n\r\n//                 // gzaLog(\"222====\", newx, newy, index, i + k, map[index]);\r\n//                 let quan = i + k;\r\n//                 arr.push({ quan: quan, index: index });\r\n//             }\r\n//         }\r\n\r\n//         arr = arr.sort((a: any, b: any) => {\r\n//             return a.quan - b.quan;\r\n//         });\r\n\r\n//         // let arr2 = [];\r\n//         // for (let k = 0; k < arr.length; k++) {\r\n//         //     // let index = mapHeight * arr[k].index + arr[k].index;\r\n//         //     arr2.push(arr[k].index);\r\n//         // }\r\n//         // gzaLog(\"寻找替代点\", ...arr2);\r\n\r\n//         if (arr.length) {\r\n//             return arr[0].index;\r\n//         } else {\r\n//             return null;\r\n//         }\r\n//     }\r\n\r\n\r\n//     //从当前跳点,上下左右寻找,直到找到了下一个跳点\r\n//     private static jumpToFind(mapData: MapData, mapWidth: number, mapHeight: number, tempMap: boolean[], jumpPointXY: Map<number, number[]>, close: Map<number, boolean>, parent: PathInfo, endX: number, endY: number) {\r\n//         let nowX = parent.x;\r\n//         let nowY = parent.y;\r\n//         if (nowX == endX && nowY == endY) {\r\n//             return;\r\n//         }\r\n\r\n//         let tagLeft = true;\r\n//         let tagRight = true;\r\n//         let tagUp = true;\r\n//         let tagDown = true;\r\n//         //判断上下左右是否为强迫邻居\r\n\r\n//         if (tagRight) {\r\n//             //往右\r\n//             for (let i = nowX + 1; i < mapWidth; i++) {\r\n//                 if (close.has(i * 1000 + nowY)) {\r\n//                     break;\r\n//                 }\r\n\r\n//                 if (i == endX && nowY == endY) {\r\n//                     // let path = new PathInfo({ x: i, y: nowY }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = i;\r\n//                     path.y = nowY;\r\n//                     path.parent = parent;\r\n//                     parent.links = [path];\r\n//                     return;\r\n//                 }\r\n//                 let index = mapData.getIndexByXY(i, nowY);\r\n\r\n//                 if (!tempMap[index]) {\r\n//                     //碰壁,停止继续检索\r\n//                     break;\r\n//                 }\r\n\r\n//                 let isjump = JPSPlus.isJumpPoint(mapData, mapWidth, mapHeight, tempMap, jumpPointXY, i, nowY, endX, endY);\r\n//                 if (isjump) {\r\n//                     // let path = new PathInfo({ x: i, y: nowY }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = i;\r\n//                     path.y = nowY;\r\n//                     path.parent = parent;\r\n//                     parent.links.push(path);\r\n//                     jumpPointXY.set(index, [i, nowY]);\r\n//                 }\r\n//             }\r\n//         }\r\n//         if (tagLeft) {\r\n//             //往左\r\n//             for (let i = nowX - 1; i >= 0; i--) {\r\n//                 if (close.has(i * 1000 + nowY)) {\r\n//                     break;\r\n//                 }\r\n//                 if (i == endX && nowY == endY) {\r\n//                     // let path = new PathInfo({ x: i, y: nowY }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = i;\r\n//                     path.y = nowY;\r\n//                     path.parent = parent;\r\n//                     parent.links = [path];\r\n//                     return;\r\n//                 }\r\n//                 let index = mapData.getIndexByXY(i, nowY);\r\n//                 if (!tempMap[index]) {\r\n//                     //碰壁,停止继续检索\r\n//                     break;\r\n//                 }\r\n\r\n//                 let isjump = JPSPlus.isJumpPoint(mapData, mapWidth, mapHeight, tempMap, jumpPointXY, i, nowY, endX, endY);\r\n//                 if (isjump) {\r\n//                     jumpPointXY.set(index, [i, nowY]);\r\n//                     // let path = new PathInfo({ x: i, y: nowY }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = i;\r\n//                     path.y = nowY;\r\n//                     path.parent = parent;\r\n//                     parent.links.push(path);\r\n//                 }\r\n//             }\r\n//         }\r\n//         if (tagUp) {\r\n//             //往上\r\n//             for (let i = nowY - 1; i >= 0; i--) {\r\n//                 if (close.has(nowX * 1000 + i)) {\r\n//                     break;\r\n//                 }\r\n\r\n//                 if (nowX == endX && i == endY) {\r\n//                     // let path = new PathInfo({ x: nowX, y: i }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = nowX;\r\n//                     path.y = i;\r\n//                     path.parent = parent;\r\n//                     parent.links = [path];\r\n//                     return;\r\n//                 }\r\n//                 let index = mapData.getIndexByXY(nowX, i);\r\n//                 if (!tempMap[index]) {\r\n//                     //碰壁,停止继续检索\r\n//                     break;\r\n//                 }\r\n\r\n//                 let isjump = JPSPlus.isJumpPoint(mapData, mapWidth, mapHeight, tempMap, jumpPointXY, nowX, i, endX, endY);\r\n//                 if (isjump) {\r\n//                     jumpPointXY.set(index, [nowX, i]);\r\n//                     // let path = new PathInfo({ x: nowX, y: i }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = nowX;\r\n//                     path.y = i;\r\n//                     path.parent = parent;\r\n//                     parent.links.push(path);\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         if (tagDown) {\r\n//             //往下\r\n//             for (let i = nowY + 1; i < mapHeight; i++) {\r\n//                 if (close.has(nowX * 1000 + i)) {\r\n//                     break;\r\n//                 }\r\n\r\n//                 if (nowX == endX && i == endY) {\r\n//                     // let path = new PathInfo({ x: nowX, y: i }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = nowX;\r\n//                     path.y = i;\r\n//                     path.parent = parent;\r\n//                     parent.links = [path];\r\n//                     return;\r\n//                 }\r\n//                 let index = mapData.getIndexByXY(nowX, i);\r\n//                 if (!tempMap[index]) {\r\n//                     //碰壁,停止继续检索\r\n//                     break;\r\n//                 }\r\n\r\n//                 //下一个格子是墙壁,才进行跳点检测,否则继续前行\r\n//                 let isjump = JPSPlus.isJumpPoint(mapData, mapWidth, mapHeight, tempMap, jumpPointXY, nowX, i, endX, endY);\r\n//                 if (isjump) {\r\n//                     jumpPointXY.set(index, [nowX, i]);\r\n//                     // let path = new PathInfo({ x: nowX, y: i }, parent);\r\n//                     let path = ObjectPool.get(PathInfo);\r\n//                     path.x = nowX;\r\n//                     path.y = i;\r\n//                     path.parent = parent;\r\n//                     parent.links.push(path);\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n\r\n//         //进行剪枝 如果当前跳点，可以直线抵达下一个跳点，该跳点为中间跳点，在搜索的时候，可以把该跳点移出openset,减少搜索次数，\r\n//         for (let i = 0; i < parent.links.length; i++) {\r\n//             let a = parent.links[i];\r\n//             if (a.x == endX && a.y == endY) {\r\n//                 parent.links = [a];\r\n//                 return;\r\n//             }\r\n//         }\r\n//     }\r\n\r\n//     private static isJumpPoint(mapData: MapData, mapWidth: number, mapHeight: number, tempMap: boolean[], jumpPointXY, nowX: number, nowY: number, endX: number, endY: number): boolean {\r\n//         //判断是否为终点\r\n//         if (nowX == endX && nowY == endY) {\r\n//             return true;\r\n//         }\r\n\r\n\r\n//         {\r\n//             let tagLeft = true;\r\n//             let tagRight = true;\r\n//             let tagUp = true;\r\n//             let tagDown = true;\r\n//             //判断上下左右是否为强迫邻居\r\n\r\n//             let upY = nowY - 1;\r\n//             let downY = nowY + 1;\r\n\r\n//             let rightX = nowX + 1;\r\n//             let leftX = nowX - 1;\r\n//             //左边界\r\n//             if (tagLeft) {\r\n//                 if (leftX >= 0) {\r\n//                     let nindex = mapData.getIndexByXY(leftX, nowY);\r\n//                     if (!tempMap[nindex]) {\r\n//                         //不能走,是一个强迫邻居\r\n//                         return true;\r\n//                     }\r\n//                 }\r\n//             }\r\n//             //右边界\r\n//             if (tagRight) {\r\n//                 if (rightX < mapWidth) {\r\n//                     let nindex = mapData.getIndexByXY(rightX, nowY);\r\n//                     if (!tempMap[nindex]) {\r\n//                         //不能走,是一个强迫邻居\r\n//                         return true;\r\n//                     }\r\n//                 }\r\n//             }\r\n\r\n//             //上边界\r\n//             if (tagUp) {\r\n//                 if (upY >= 0) {\r\n//                     let nindex = mapData.getIndexByXY(nowX, upY);\r\n//                     if (!tempMap[nindex]) {\r\n//                         //不能走,是一个强迫邻居\r\n//                         return true;\r\n//                     }\r\n//                 }\r\n//             }\r\n\r\n//             //下边界\r\n//             if (tagDown) {\r\n//                 if (downY < mapHeight) {\r\n//                     let nindex = mapData.getIndexByXY(nowX, downY);\r\n//                     if (!tempMap[nindex]) {\r\n//                         //不能走,是一个强迫邻居\r\n//                         return true;\r\n//                     }\r\n//                 }\r\n//             }\r\n//         }\r\n\r\n//         //如果斜向或者直线移动可以抵达跳点，则该格子是跳点\r\n//         for (let key of jumpPointXY.keys()) {\r\n//             let pos = jumpPointXY.get(key);\r\n//             if (pos[0] == nowX || pos[1] == nowY) {\r\n//                 return true;\r\n//             }\r\n//         }\r\n//         return false;\r\n//     }\r\n\r\n\r\n// }"]}